//#GOGP_IGNORE_BEGIN
///////////////////////////////////////////////////////////////////
//
// !!!!!!!!!!!! NEVER MODIFY THIS FILE MANUALLY !!!!!!!!!!!!
//
// This file was auto-generated by tool [github.com/vipally/gogp]
// Last update at: [Thu Mar 16 2017 23:33:38]
// Generate from:
//   [github.com/vipally/gx/stl/gp/lfdeque.gp.go]
//   [github.com/vipally/gx/stl/gp/gp.gpg] [GOGP_REVERSE_lfdeque]
//
// Tool [github.com/vipally/gogp] info:
// CopyRight 2016 @Ally Dale. All rights reserved.
// Author  : Ally Dale(vipally@gmail.com)
// Blog    : http://blog.csdn.net/vipally
// Site    : https://github.com/vipally
// BuildAt : [Oct 24 2016 20:25:45]
// Version : 3.0.0.final
// 
///////////////////////////////////////////////////////////////////
//#GOGP_IGNORE_END

<PACKAGE>

import (
	"sync/atomic"
	"time"
)

//#GOGP_REQUIRE(github.com/vipally/gogp/lib/fakedef,_)

//#GOGP_ONCE
const (
	defaultLFDequeCap = 8
) //
//#GOGP_END_ONCE

//deque object
type <GLOBAL_NAME_PREFIX>LFDeque struct {
	//real data is [head,tail)
	//buffer d is cycle, that is to say, next(len(d)-1)=0, prev(0)=len(d)-1
	//so if tail<head, data is [head, end, 0, tail)
	//head point to the first elem  available for read
	//tail point to the first space available for write
	//headtail=tai<<32 + head
	headtail uint64
	busy     uint64
	d        []<VALUE_TYPE>
}

//new object
func NewGOGPDequeNamePrefixLFDeque(bufSize int32) *<GLOBAL_NAME_PREFIX>LFDeque {
	r := &<GLOBAL_NAME_PREFIX>LFDeque{}
	r.Init(bufSize)
	return r
}

//init
func (this *<GLOBAL_NAME_PREFIX>LFDeque) Init(bufSize int32) {
	if nil == this.d {
		if bufSize <= 0 {
			bufSize = defaultLFDequeCap //default buffer size
		}
		this.newBuf(bufSize)
	}
	this.Clear()
	return
}

//create new buffer
func (this *<GLOBAL_NAME_PREFIX>LFDeque) newBuf(bufSize int32) {
	if bufSize > 0 {
		size := int(bufSize)
		this.d = make([]<VALUE_TYPE>, size, size) //the same cap and len
	}
}

//clear all deque data
func (this *<GLOBAL_NAME_PREFIX>LFDeque) Clear() {
	atomic.StoreUint64(&this.headtail, 0)
	this.busy = 0
}

//push to front of deque, maybe block when busy
func (this *<GLOBAL_NAME_PREFIX>LFDeque) PushFront(v <VALUE_TYPE>) (ok bool) {
	if ok = true; ok {
		if nil == this.d { //init if needed
			this.Init(-1)
		}

		for {
			head, tail, headtail := this.headTail()
			head = this.prev(head)
			if head == tail { //buffer full, wait
				atomic.AddUint64(&this.busy, 1)
				time.Sleep(time.Millisecond)
				continue
			}
			this.d[head] = v
			ht := this.makeHeadTail(head, tail)
			if atomic.CompareAndSwapUint64(&this.headtail, headtail, ht) {
				break
			}
		}
	}
	return true
}

//push to back of deque, maybe block when busy
func (this *<GLOBAL_NAME_PREFIX>LFDeque) PushBack(v <VALUE_TYPE>) (ok bool) {
	if ok = true; ok {
		if nil == this.d { //init if needed
			this.Init(-1)
		}

		for {
			head, tail, headtail := this.headTail()
			tailNext := this.next(tail)
			if head == tailNext { //buffer full, wait
				atomic.AddUint64(&this.busy, 1)
				time.Sleep(time.Millisecond)
				continue
			}
			this.d[tail] = v
			ht := this.makeHeadTail(head, tailNext)
			if atomic.CompareAndSwapUint64(&this.headtail, headtail, ht) {
				break
			}
		}
	}
	return true
}

//pop front of deque
func (this *<GLOBAL_NAME_PREFIX>LFDeque) PopFront() (front <VALUE_TYPE>, ok bool) {
	for {
		head, tail, headtail := this.headTail()
		if ok = head != tail; !ok {
			break
		}
		front = this.d[head]
		head = this.next(head)
		ht := this.makeHeadTail(head, tail)
		if atomic.CompareAndSwapUint64(&this.headtail, headtail, ht) {
			break
		}
	}
	return
}

//pop back of deque
func (this *<GLOBAL_NAME_PREFIX>LFDeque) PopBack() (back <VALUE_TYPE>, ok bool) {
	for {
		head, tail, headtail := this.headTail()
		tailPrev := this.prev(tail)
		if ok = head != tail; !ok {
			break
		}
		back = this.d[tailPrev]
		ht := this.makeHeadTail(head, tailPrev)
		if atomic.CompareAndSwapUint64(&this.headtail, headtail, ht) {
			break
		}
	}
	return
}

//data buffer size
func (this *<GLOBAL_NAME_PREFIX>LFDeque) Cap() uint32 {
	return uint32(len(this.d))
}

//size of deque
func (this *<GLOBAL_NAME_PREFIX>LFDeque) Size() (size uint32) {
	head, tail, _ := this.headTail()
	if tail >= head {
		size = tail - head
	} else {
		size = this.Cap() - (head - tail)
	}
	return
}

func (this *<GLOBAL_NAME_PREFIX>LFDeque) Busy() uint64 {
	return atomic.LoadUint64(&this.busy)
}

//if deque is empty
func (this *<GLOBAL_NAME_PREFIX>LFDeque) Empty() bool {
	return this.Size() == 0
}

func (this *<GLOBAL_NAME_PREFIX>LFDeque) headTail() (head, tail uint32, headtail uint64) {
	headtail = atomic.LoadUint64(&this.headtail)
	head = uint32(headtail & 0xFFFFFFFF)
	tail = uint32((headtail >> 32) & 0xFFFFFFFF)
	return
}

func (this *<GLOBAL_NAME_PREFIX>LFDeque) makeHeadTail(head, tail uint32) uint64 {
	headtail := (uint64(head) & 0xFFFFFFFF) | (uint64(tail) & 0xFFFFFFFF << 32)
	return headtail
}

//next buff
func (this *<GLOBAL_NAME_PREFIX>LFDeque) next(idx uint32) (r uint32) {
	if r = idx + 1; r >= this.Cap() {
		r = 0
	}
	return
}

//prev buff
func (this *<GLOBAL_NAME_PREFIX>LFDeque) prev(idx uint32) (r uint32) {
	if r = idx - 1; r < 0 {
		r = this.Cap() - 1
	}
	return
}

